/*
* Copyright (c) 2018 ZeroPass
* Distributed under the MIT software license, see the accompanying
* file LICENSE or https://opensource.org/licenses/MIT.
*/

package io.zeropass.trid.passport;


import android.nfc.tech.IsoDep;

import java.security.InvalidParameterException;
import java.util.logging.Logger;

import io.zeropass.trid.ISO7816;
import io.zeropass.trid.Utils;
import io.zeropass.trid.net.ApduCmd;
import io.zeropass.trid.net.ApduResult;
import io.zeropass.trid.net.NfcTransmitter;
import io.zeropass.trid.net.NfcTransmitterError;
import io.zeropass.trid.smartcard.SmartCardError;

public class PassportApdu {
    private static final Logger Journal = Logger.getLogger("passport");
    private NfcTransmitter mTrans;

    public PassportApdu(IsoDep isoDep) throws NfcTransmitterError, PassportError {
        mTrans = new NfcTransmitter(isoDep);
        mTrans.connect();

        if(mTrans.isConnected()) {
            Utils.printDebug(Journal.getName(), "Nfc transmitter connected. [ATR: " + Utils.hexToStr(mTrans.getATR()) + "]");
        }
        else {
            throw new PassportError("Could not connect to NFC transmitter");
        }
    }





    /*Returns signature generated by ICC */
    public byte[] signData(byte[] data) throws NfcTransmitterError {
        if(data.length != 8) {
            return null;
        }

        Utils.printDebug(Journal.getName(), "Sending data to be signed by ICU: " + Utils.hexToStr(data));

        ApduResult res = mTrans.transceive(new ApduCmd(ISO7816.CLA_NO_SM, ISO7816.INS_INTERNAL_AUTHENTICATE, 0x00, 0x00, data, 256));
        if(res.statusCode() != ISO7816.SW_NO_ERROR) {
            return null;
        }

        return res.data();
    }

    protected void setSessionKey(PassportSessionKey key) {
        mTrans.setSession(new PassportSessionCipher(key));
    }

    protected void selectApplet(final byte[] appletId) throws NfcTransmitterError {
        ApduResult result = mTrans.transceive(new ApduCmd(ISO7816.CLA_NO_SM, ISO7816.INS_SELECT_FILE, 0x04, 0x0c, appletId));
    }

    /**
     * Request random challange from IC needed of BAC
     * */
    protected byte[] getChallenge() throws NfcTransmitterError {
        Utils.printDebug(Journal.getName(), "Requesting challenge from IC");

        ApduCmd apdu = new ApduCmd(ISO7816.CLA_NO_SM, ISO7816.INS_GET_CHALLENGE, 0x00, 0x00, 8);
        ApduResult result = mTrans.transceive(apdu);

        if(result.statusCode() != ISO7816.SW_NO_ERROR) {
            Journal.warning("getChallenge returned status code: " + result.statusCode());
            return null;
        }

        Utils.printDebug(Journal.getName(), "Received challenge from IC: RND.IC=" + Utils.hexToStr(result.data()));
        return result.data();
    }

    /*
    *  Sends EXTERNAL AUTHENTICATE command to ICC
    *
    *  @param ApduEAData
    *  @returns response ApduEAData from ICC
    */
    protected ApduEAData externalAuthenticate(ApduEAData data) throws NfcTransmitterError {
        Utils.printDebug(Journal.getName(), String.format("externalAuthenticate: sending data to ICC:\nE.IFD=%s\nM.IFD=%s", Utils.hexToStr(data.E), Utils.hexToStr(data.M)));

        ApduCmd apdu = new ApduCmd(ISO7816.CLA_NO_SM, ISO7816.INS_EXTERNAL_AUTHENTICATE, 0x00, 0x00, data.toBytes(), 0x28);
        ApduResult result = mTrans.transceive(apdu);

        if(result.statusCode() != ISO7816.SW_NO_ERROR) {
            Journal.warning("externalAuthenticate, ICC returned status code: " + result.statusCode());
            return null;
        }

        try {
            return new ApduEAData(result.data());
        } catch (InvalidParameterException e) {
            Journal.warning("externalAuthenticate error: an exception was thrown e= " + e.getMessage());
            return null;
        }
    }

    private static void checkFileOperationResult(ApduResult result) throws SmartCardError {
        short sw = result.statusCode();
        switch (sw) {
            case ISO7816.SW_NO_ERROR:
                return;
            case ISO7816.SW_FILE_NOT_FOUND:
                throw new SmartCardError("File not found!", sw);
            case ISO7816.SW_SECURITY_STATUS_NOT_SATISFIED:
            case ISO7816.SW_CONDITIONS_NOT_SATISFIED:
            case ISO7816.SW_COMMAND_NOT_ALLOWED:
                throw new SmartCardError("Access to file denied", sw);
        }
        throw new SmartCardError("Error occurred", sw);
    }


    /* Should be moved to SmartCard class */

    public void selectFile(short fileId) throws NfcTransmitterError, SmartCardError {
        byte[] fiddle = { (byte) ((fileId >> 8) & 0xFF), (byte) (fileId & 0xFF) };
        ApduCmd capdu = new ApduCmd(ISO7816.CLA_NO_SM, ISO7816.INS_SELECT_FILE, (byte) 0x02, (byte) 0x0c, fiddle, 0);
        ApduResult rapdu = mTrans.transceive(capdu);

        if( rapdu == null ) {
            return;
        }

        checkFileOperationResult(rapdu);
    }

    public byte [] readBinary(int offset, int len) throws NfcTransmitterError {
        if (len == 0) {
            return null;
        }

        byte offsetHi = (byte)((offset & 0xFF00) >> 8);
        byte offsetLo = (byte)(offset & 0xFF);

        ApduCmd cmd = new ApduCmd(ISO7816.CLA_NO_SM, ISO7816.INS_READ_BINARY, offsetHi, offsetLo, len);
        ApduResult result = mTrans.transceive(cmd);

        if(result == null) {
            Journal.warning("Failed to read binary!");
            return null;
        }

        if(result.statusCode() != ISO7816.SW_NO_ERROR) {
            Journal.warning("Passport returned an error while trying to read binary: sw=" + result.statusCode());
        }
        return result.data();
    }
}
